---

templateKey: 'blog-post'
title: '하이퍼레저 패브릭 1.2 컨셉요약'
date: 2019-02-12T15:24:53.100Z
description: >-
  하이퍼레저 패브릭 1.2 컨셉요약
tags:
  - hyperledger fabric
---

# 개요

* 이미 협업하기로 한 조직간에 데이터를 공유하고자 할때 사용
* 블록체인 고유의 진위여부 합의알고리즘 같은 건 없음.
  * 트렌젝션 진행 전과정을 합의라고 우김. ^
* 트렌제션 실행 -> 오더링 -> 검증 -> 반영

# 구축순서

## 1. 피어

* 각 피어는 분산원장과 체인코드를 기본적으로 가진다.
* 하나의 피어는 복수개의 분산원장과 체인코드를 가진다.
* 하나의 체인코드는 다수개의 분산원장에 접근할 수 있다.
* 체인코드를 통해서 분산원장에 접근한다. (직접원장에 접근은 권장하지 않음.)

## 2. Dapp

* Dapp 은 SDK 를 통해 체인코드를 실행시킨다.
* 데이터 읽기 
  * 체인코드를 실행해서 결과는 얻는다.
* 데이터 쓰기
  * 체인코드를 톻해, 시뮬레이션으로 실행하고 그 결과값 반환받고,
  * 결과값을 오더링에 보낸다.
  * 오더링은 관련 피어들에게 보내고,
  * 업데이트된 최종결과를 Dapp 에 반환한다.

## 3. 시스템 체인코드

* 사용자가 만든 체인코드가 아닌, 기본적으로 가지고 있는 체인코드
* QSCC (CLI) : Query Sytem ChainCode :  원장데이터 조회시
* ESCC (내부) : Endorsement  : 보증피어에 의해 실행. 결과값 검증
* VSCC  (내부) : Validataion : 커밋피어에 의해 실행. 결과값 및 보증피어에 의한 보증확인
* CSCC (CLI) : Configuration : 채널설정 시 사용하는 체인코드
* LSCC (CLI) : Lifecycle : 체인코드 인스턴스화 하는 체인코드

## 4. 채널

* 채널을 통해 서로 다른 조직의 피어들을 묶는다.
* 하나의 피어는 다수개의 채널에 들어갈 수 있다.
* 트렌젝션은 채널간에만 이루어진다.

## 5. 원장

* 원장은 월드스테이트 : 현재값
* 그리고, 지난 트렌젝션들의 히스토리 로그인 블록체인으로 구성된다.
  * 블록은 오더러에 의해 만들어진다.
  * 생성된 블록은 기본의 블록체인에 연결된다.
* 블록내부
  * 헤더
    * 블록넘버
    * 현재블록해쉬값
    * 이전블록해쉬값
  * 데이터
    * 다수개의 트렉젠션 들
    * 하나의 트렉젝션 구조
      * 헤더 : 트렌젝션 버전(월드스테이트버전과 매칭), 실행되는 체인코드명
      * 서명 : 트렌젝션 생성자의 인증서 정보
      * 프로포잘 : 트렌젝션 입력값 (인자)
      *  response : 트렌젝션 결과값을 Read/Write set 형태로 반환
        * Read : 트렌젝션 실행 전 값
        * Write : 트렌젝션 실행 후 값
      * Endorsement  : 트렉젝션을 보증해 준 피어정보
      * Chancode name :
  * 메타데이터
    * 블록생성자의 식별정보, 블록내 트렌젝션 보증정보

## 6. Gossip 프로토콜

* 피어가 살아있는 지 ping 역할 프로토콜
* 피어간 분산원장 교환 프로토콜 (분산원장 동기화)
* 오더러는 조직별 리더피어와만 통신
  * 리더피어는 해당 조직내 피어들과 통신

## 7. 아이덴티티 식별

* 디지털인증서 : X.509

  * 디지털 신원증명방법

* 공개키/비밀키 PKI

  * 데이터위변조 방지
  * X.509 디지털인증서 사용

* CA (Certificate Authority) : 공개키 들을 가지고 있는 DB (기관이라고 표현 ?)

* CRL (Certificate Revocation List) : 페기된 인증서 목록들

  

## 8. MSP (Membership Service Provider)

* 각 조직은 하나의 CA를 가진다.
  * 각 피어는 Local MSP 를 가진다.
    * 어떤 노드인지, 어떤 사용자가 있는지 등 정의하는 것임 (피어, 오더러, 클라이언트 들)
* 조직을 묶는 채널에는 하나의 Channel MSP를 가진다.
  * Channel MSP 안에 참여한 피어들의 Local MSP들의 집합이 있다.
  * 결국, 채널전체의 MSP 를 보유하는 것임.
* MSP 정보구조
  * Root CA
  * Intermediate CA
  * Organizational Unit
  * Administartors : 조직운영자의 인증서
  * Revoded Certificates : 페이된 인증서
  * Signing Certificates :  
  * Keystore (private key) : 개인키
  * TLS Rood CA : 보안강화 Root CA
  * TLS Intermediate CA

## 9. 오더러

* 1단계 : 트렌젝션 제출
  * Dapp -> 보증피어에게 트랜젝션 제출
  * 해당 체인코드 시뮬레이션 실행
  * 예상한 결과값이 나오면, 보증피어는 자신의 식별자로 서명한 인증서와 Read/Write Set -> Dapp 에게 전송
  * Dapp -> 오더러에게 . (Read/Write Set, 보증피어의 인증서, 트렌젝션 내용) 을 보내다.
* 2단계 : 블록패키징
  * 트렌젝션을 받은 오더러는 순서대로 묶어서, 블록을 만든다.
* 3단계 : 검증 
  * 모든 피어는 커피트 피어입니다.
  * 오더러는 만든 블록은 조직의 리더피어들에게 전달한다.
  * 피어는 해당 블록인 제대로 생성된 블록인지 검증한다.
    * 블록에 포함된 결과값이 정상인지
    * 각각의 트렌젝션 결과값이 보증정책에 부합되는지 (보증노드 모두에게로 부터 정상여부확인)
    * 문제 없으면, 로컬저장소의 블록체인에 블록 추가하고, World State 에 반영
* 카프카 오더링서비스
  * 멀티파티셔닝 폴트톨로런스 로드벨런싱 구조임. (안정적인 구조)
  * 오더러는 카프카의 생산자
  * 피어는 카프카의 소비자

## 10 구축순서정리

1. 오더링 서비스 구축, 각 조직에는 CA 가 있다.
2. 오더링서비스를 통해 채널을 생성
3. 피어노드를 생성하고 오더링이 만든 채널에 연결
4. 피어노드에 분산원장저장
5. 피어노드에 체인코드설정
6. Dapp 개발
7. 새로운 조직/채널 추가
   1. 분산원장, 체인코드 설치



## 피어노드의 역할

* 커미팅 피어 
  * 최신블록에 대한 검증
  * 모든 피어는 커미팅 노드임.
* 보증피어 
  * 트렌젝션 보증여부
  * 체인코드 시뮬에이션 수행
* 리더피어
  * 조직내 하나의 대표피어
* 앵커피어
  * 조직내 대표로 다른 조직들과 통신하는 피어

# 트렌젝션 흐름

1. Dapp (SDK) -> Endorsing Peers (보증피어)
2. 보증피어 체인코드 시뮬레이션 실행 -> 결과(Read/Write set, if OK 피어인증서) -> Dapp
   1. 트랜젝션의 Proposal(인자값), 체인코드명, 월드상태DB를 참조하여 실행함.
   2. Read/Write Set 이 올바른지 ?
   3. 동일트렌잭션 발생여부 (replay 체크)
   4. 사용자 MSP 유효성 (실행권한)
   5. 사용자 분산원장 업데이트 권한체크 (channel MSP)
3. Dapp -> 오더러
   1. 보증정책에 의한, 다수의 보증피어 결과를 받아, 
      1. 모두 결과값이 같은지 체크
      2. 보증한 인증서가 모두 있는지 체크
      3. 값이 틀리거나, 인증서 없이도... 오더러에게 전송할 수 있음. (커미팅피어에서 무효값처리예상)
   2. Dapp -> (RW Set + 보증피어의 보증서)을 오더러에게
4. 오더러 -> 블록생성 -> 커미팅피어
   1. 받은 트랜젝션순서대로 블록생성
   2. 오더러는 다수의 채널에 속할 수 있다.
      1. 채널별로 구분하여, 트랜젝션을 정렬하고 블록생성을 한다.
   3. 생성된 블록을 커미팅피어에 전송
5. 커미팅피어 (분산원장을 가지고 있는 피어임.)
   1. 블록검증 - VSCC 시스템 체인코드 실행
      1. 보증서버의 인증서를 존재를 통해, 보증정책 유효성확인
      2. RW set 확인 : Read set 키값 사용시 StateDB 레코드버전(블록버전) 확인 후,... 현재 버전과일치확인 ????
   2. 검증된 결과를 블록체인에 연결 반영
      1. 유효/무효 모두 체인에는 연결
      2. 월드스테이트는 유효한 것만 반영 (최종정상상태임으로)

# 합의 뜻

* 일련의 절차 수행을 합의라고 함.
  * 보증정책을 통한 보증
  * 트랜젝션 순서에 따른 오더링
  * 블록의 유효성 검증을 통한 최신블록 반영

# 프라이빗 데이터

* 프라이빗 데이터 콜렉션 
* 동일한 채널내에서, ... 소그룹으로 자기들끼지만 또 통신하고 싶을 때,
  * 채널의 월드스태이트 DB는 공동사용
  * PDC 트렌젝션 데이터는 SideDB 에 들어감.
  * PDC 트랜젝션도, 월드스테이트에 기록되나,... 내용은 없고 SideDB 의 내용위치 해쉬값만 들어감.
  * SideDB에 접근권하는 인증된피어만 접근가능함. (사이드DB = 프라이빗상태DB)
  * 프라이빗상태DB 반영순서의 기록은 블록체인말고. write set 로그라는 것에 순서대로 기록함. (블록체인과 같은 효과)
* Dapp -> 프라이빗트랙젝션 -> 보증피어 (SideDB 해쉬값) -> Dapp -> 오더러 -> 커미팅노드 -> 블록반영
  * 보증피어단계에서, SideDB 데이터를 각 프라이빗피어들의 임시DB(transient data store)에 싱크해 놓습니다. 
  * 커미팅노드에서 블록반영 시,.. 문제 없을 때,.. .임시DB내의 데이터를 SideDB에 초종 반영합니다.

# 버전1.3 추가 (GDRP 개인데이터 보호 기능강화)

* 1.2에서 사이드DB를 통해 개인정보 노출을 통제하고, 관리,삭제가 가능해 짐.

* 1.3에서는 영지식증명을 통한 트렌젝션 익명성강화

* 블록체인의 데이터 유효한 거래 및 기간 설정을 통해,... 접근통제관리

  














