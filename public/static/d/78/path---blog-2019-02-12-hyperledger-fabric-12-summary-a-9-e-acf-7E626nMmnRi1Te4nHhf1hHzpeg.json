{"data":{"markdownRemark":{"id":"3334134a-8d79-51d0-850e-e6164cdd339f","html":"<h1>개요</h1>\n<ul>\n<li>이미 협업하기로 한 조직간에 데이터를 공유하고자 할때 사용</li>\n<li>\n<p>블록체인 고유의 진위여부 합의알고리즘 같은 건 없음.</p>\n<ul>\n<li>트렌젝션 진행 전과정을 합의라고 우김. ^</li>\n</ul>\n</li>\n<li>트렌제션 실행 -> 오더링 -> 검증 -> 반영</li>\n</ul>\n<h1>구축순서</h1>\n<h2>1. 피어</h2>\n<ul>\n<li>각 피어는 분산원장과 체인코드를 기본적으로 가진다.</li>\n<li>하나의 피어는 복수개의 분산원장과 체인코드를 가진다.</li>\n<li>하나의 체인코드는 다수개의 분산원장에 접근할 수 있다.</li>\n<li>체인코드를 통해서 분산원장에 접근한다. (직접원장에 접근은 권장하지 않음.)</li>\n</ul>\n<h2>2. Dapp</h2>\n<ul>\n<li>Dapp 은 SDK 를 통해 체인코드를 실행시킨다.</li>\n<li>\n<p>데이터 읽기 </p>\n<ul>\n<li>체인코드를 실행해서 결과는 얻는다.</li>\n</ul>\n</li>\n<li>\n<p>데이터 쓰기</p>\n<ul>\n<li>체인코드를 톻해, 시뮬레이션으로 실행하고 그 결과값 반환받고,</li>\n<li>결과값을 오더링에 보낸다.</li>\n<li>오더링은 관련 피어들에게 보내고,</li>\n<li>업데이트된 최종결과를 Dapp 에 반환한다.</li>\n</ul>\n</li>\n</ul>\n<h2>3. 시스템 체인코드</h2>\n<ul>\n<li>사용자가 만든 체인코드가 아닌, 기본적으로 가지고 있는 체인코드</li>\n<li>QSCC (CLI) : Query Sytem ChainCode :  원장데이터 조회시</li>\n<li>ESCC (내부) : Endorsement  : 보증피어에 의해 실행. 결과값 검증</li>\n<li>VSCC  (내부) : Validataion : 커밋피어에 의해 실행. 결과값 및 보증피어에 의한 보증확인</li>\n<li>CSCC (CLI) : Configuration : 채널설정 시 사용하는 체인코드</li>\n<li>LSCC (CLI) : Lifecycle : 체인코드 인스턴스화 하는 체인코드</li>\n</ul>\n<h2>4. 채널</h2>\n<ul>\n<li>채널을 통해 서로 다른 조직의 피어들을 묶는다.</li>\n<li>하나의 피어는 다수개의 채널에 들어갈 수 있다.</li>\n<li>트렌젝션은 채널간에만 이루어진다.</li>\n</ul>\n<h2>5. 원장</h2>\n<ul>\n<li>원장은 월드스테이트 : 현재값</li>\n<li>\n<p>그리고, 지난 트렌젝션들의 히스토리 로그인 블록체인으로 구성된다.</p>\n<ul>\n<li>블록은 오더러에 의해 만들어진다.</li>\n<li>생성된 블록은 기본의 블록체인에 연결된다.</li>\n</ul>\n</li>\n<li>\n<p>블록내부</p>\n<ul>\n<li>헤더</li>\n<li>블록넘버</li>\n<li>현재블록해쉬값</li>\n<li>이전블록해쉬값</li>\n<li>데이터</li>\n<li>다수개의 트렉젠션 들</li>\n<li>\n<p>하나의 트렉젝션 구조</p>\n<ul>\n<li>헤더 : 트렌젝션 버전(월드스테이트버전과 매칭), 실행되는 체인코드명</li>\n<li>서명 : 트렌젝션 생성자의 인증서 정보</li>\n<li>프로포잘 : 트렌젝션 입력값 (인자)</li>\n<li>response : 트렌젝션 결과값을 Read/Write set 형태로 반환</li>\n<li>Read : 트렌젝션 실행 전 값</li>\n<li>Write : 트렌젝션 실행 후 값</li>\n<li>Endorsement  : 트렉젝션을 보증해 준 피어정보</li>\n<li>Chancode name :</li>\n</ul>\n</li>\n<li>메타데이터</li>\n<li>블록생성자의 식별정보, 블록내 트렌젝션 보증정보</li>\n</ul>\n</li>\n</ul>\n<h2>6. Gossip 프로토콜</h2>\n<ul>\n<li>피어가 살아있는 지 ping 역할 프로토콜</li>\n<li>피어간 분산원장 교환 프로토콜 (분산원장 동기화)</li>\n<li>\n<p>오더러는 조직별 리더피어와만 통신</p>\n<ul>\n<li>리더피어는 해당 조직내 피어들과 통신</li>\n</ul>\n</li>\n</ul>\n<h2>7. 아이덴티티 식별</h2>\n<ul>\n<li>\n<p>디지털인증서 : X.509</p>\n<ul>\n<li>디지털 신원증명방법</li>\n</ul>\n</li>\n<li>\n<p>공개키/비밀키 PKI</p>\n<ul>\n<li>데이터위변조 방지</li>\n<li>X.509 디지털인증서 사용</li>\n</ul>\n</li>\n<li>\n<p>CA (Certificate Authority) : 공개키 들을 가지고 있는 DB (기관이라고 표현 ?)</p>\n</li>\n<li>\n<p>CRL (Certificate Revocation List) : 페기된 인증서 목록들</p>\n</li>\n</ul>\n<h2>8. MSP (Membership Service Provider)</h2>\n<ul>\n<li>\n<p>각 조직은 하나의 CA를 가진다.</p>\n<ul>\n<li>각 피어는 Local MSP 를 가진다.</li>\n<li>어떤 노드인지, 어떤 사용자가 있는지 등 정의하는 것임 (피어, 오더러, 클라이언트 들)</li>\n</ul>\n</li>\n<li>\n<p>조직을 묶는 채널에는 하나의 Channel MSP를 가진다.</p>\n<ul>\n<li>Channel MSP 안에 참여한 피어들의 Local MSP들의 집합이 있다.</li>\n<li>결국, 채널전체의 MSP 를 보유하는 것임.</li>\n</ul>\n</li>\n<li>\n<p>MSP 정보구조</p>\n<ul>\n<li>Root CA</li>\n<li>Intermediate CA</li>\n<li>Organizational Unit</li>\n<li>Administartors : 조직운영자의 인증서</li>\n<li>Revoded Certificates : 페이된 인증서</li>\n<li>Signing Certificates :  </li>\n<li>Keystore (private key) : 개인키</li>\n<li>TLS Rood CA : 보안강화 Root CA</li>\n<li>TLS Intermediate CA</li>\n</ul>\n</li>\n</ul>\n<h2>9. 오더러</h2>\n<ul>\n<li>\n<p>1단계 : 트렌젝션 제출</p>\n<ul>\n<li>Dapp -> 보증피어에게 트랜젝션 제출</li>\n<li>해당 체인코드 시뮬레이션 실행</li>\n<li>예상한 결과값이 나오면, 보증피어는 자신의 식별자로 서명한 인증서와 Read/Write Set -> Dapp 에게 전송</li>\n<li>Dapp -> 오더러에게 . (Read/Write Set, 보증피어의 인증서, 트렌젝션 내용) 을 보내다.</li>\n</ul>\n</li>\n<li>\n<p>2단계 : 블록패키징</p>\n<ul>\n<li>트렌젝션을 받은 오더러는 순서대로 묶어서, 블록을 만든다.</li>\n</ul>\n</li>\n<li>\n<p>3단계 : 검증 </p>\n<ul>\n<li>모든 피어는 커피트 피어입니다.</li>\n<li>오더러는 만든 블록은 조직의 리더피어들에게 전달한다.</li>\n<li>피어는 해당 블록인 제대로 생성된 블록인지 검증한다.</li>\n<li>블록에 포함된 결과값이 정상인지</li>\n<li>각각의 트렌젝션 결과값이 보증정책에 부합되는지 (보증노드 모두에게로 부터 정상여부확인)</li>\n<li>문제 없으면, 로컬저장소의 블록체인에 블록 추가하고, World State 에 반영</li>\n</ul>\n</li>\n<li>\n<p>카프카 오더링서비스</p>\n<ul>\n<li>멀티파티셔닝 폴트톨로런스 로드벨런싱 구조임. (안정적인 구조)</li>\n<li>오더러는 카프카의 생산자</li>\n<li>피어는 카프카의 소비자</li>\n</ul>\n</li>\n</ul>\n<h2>10 구축순서정리</h2>\n<ol>\n<li>오더링 서비스 구축, 각 조직에는 CA 가 있다.</li>\n<li>오더링서비스를 통해 채널을 생성</li>\n<li>피어노드를 생성하고 오더링이 만든 채널에 연결</li>\n<li>피어노드에 분산원장저장</li>\n<li>피어노드에 체인코드설정</li>\n<li>Dapp 개발</li>\n<li>\n<p>새로운 조직/채널 추가</p>\n<ol>\n<li>분산원장, 체인코드 설치</li>\n</ol>\n</li>\n</ol>\n<h2>피어노드의 역할</h2>\n<ul>\n<li>\n<p>커미팅 피어 </p>\n<ul>\n<li>최신블록에 대한 검증</li>\n<li>모든 피어는 커미팅 노드임.</li>\n</ul>\n</li>\n<li>\n<p>보증피어 </p>\n<ul>\n<li>트렌젝션 보증여부</li>\n<li>체인코드 시뮬에이션 수행</li>\n</ul>\n</li>\n<li>\n<p>리더피어</p>\n<ul>\n<li>조직내 하나의 대표피어</li>\n</ul>\n</li>\n<li>\n<p>앵커피어</p>\n<ul>\n<li>조직내 대표로 다른 조직들과 통신하는 피어</li>\n</ul>\n</li>\n</ul>\n<h1>트렌젝션 흐름</h1>\n<ol>\n<li>Dapp (SDK) -> Endorsing Peers (보증피어)</li>\n<li>\n<p>보증피어 체인코드 시뮬레이션 실행 -> 결과(Read/Write set, if OK 피어인증서) -> Dapp</p>\n<ol>\n<li>트랜젝션의 Proposal(인자값), 체인코드명, 월드상태DB를 참조하여 실행함.</li>\n<li>Read/Write Set 이 올바른지 ?</li>\n<li>동일트렌잭션 발생여부 (replay 체크)</li>\n<li>사용자 MSP 유효성 (실행권한)</li>\n<li>사용자 분산원장 업데이트 권한체크 (channel MSP)</li>\n</ol>\n</li>\n<li>\n<p>Dapp -> 오더러</p>\n<ol>\n<li>보증정책에 의한, 다수의 보증피어 결과를 받아, </li>\n<li>모두 결과값이 같은지 체크</li>\n<li>보증한 인증서가 모두 있는지 체크</li>\n<li>값이 틀리거나, 인증서 없이도... 오더러에게 전송할 수 있음. (커미팅피어에서 무효값처리예상)</li>\n<li>Dapp -> (RW Set + 보증피어의 보증서)을 오더러에게</li>\n</ol>\n</li>\n<li>\n<p>오더러 -> 블록생성 -> 커미팅피어</p>\n<ol>\n<li>받은 트랜젝션순서대로 블록생성</li>\n<li>오더러는 다수의 채널에 속할 수 있다.</li>\n<li>채널별로 구분하여, 트랜젝션을 정렬하고 블록생성을 한다.</li>\n<li>생성된 블록을 커미팅피어에 전송</li>\n</ol>\n</li>\n<li>\n<p>커미팅피어 (분산원장을 가지고 있는 피어임.)</p>\n<ol>\n<li>블록검증 - VSCC 시스템 체인코드 실행</li>\n<li>보증서버의 인증서를 존재를 통해, 보증정책 유효성확인</li>\n<li>RW set 확인 : Read set 키값 사용시 StateDB 레코드버전(블록버전) 확인 후,... 현재 버전과일치확인 ????</li>\n<li>검증된 결과를 블록체인에 연결 반영</li>\n<li>유효/무효 모두 체인에는 연결</li>\n<li>월드스테이트는 유효한 것만 반영 (최종정상상태임으로)</li>\n</ol>\n</li>\n</ol>\n<h1>합의 뜻</h1>\n<ul>\n<li>\n<p>일련의 절차 수행을 합의라고 함.</p>\n<ul>\n<li>보증정책을 통한 보증</li>\n<li>트랜젝션 순서에 따른 오더링</li>\n<li>블록의 유효성 검증을 통한 최신블록 반영</li>\n</ul>\n</li>\n</ul>\n<h1>프라이빗 데이터</h1>\n<ul>\n<li>프라이빗 데이터 콜렉션 </li>\n<li>\n<p>동일한 채널내에서, ... 소그룹으로 자기들끼지만 또 통신하고 싶을 때,</p>\n<ul>\n<li>채널의 월드스태이트 DB는 공동사용</li>\n<li>PDC 트렌젝션 데이터는 SideDB 에 들어감.</li>\n<li>PDC 트랜젝션도, 월드스테이트에 기록되나,... 내용은 없고 SideDB 의 내용위치 해쉬값만 들어감.</li>\n<li>SideDB에 접근권하는 인증된피어만 접근가능함. (사이드DB = 프라이빗상태DB)</li>\n<li>프라이빗상태DB 반영순서의 기록은 블록체인말고. write set 로그라는 것에 순서대로 기록함. (블록체인과 같은 효과)</li>\n</ul>\n</li>\n<li>\n<p>Dapp -> 프라이빗트랙젝션 -> 보증피어 (SideDB 해쉬값) -> Dapp -> 오더러 -> 커미팅노드 -> 블록반영</p>\n<ul>\n<li>보증피어단계에서, SideDB 데이터를 각 프라이빗피어들의 임시DB(transient data store)에 싱크해 놓습니다. </li>\n<li>커미팅노드에서 블록반영 시,.. 문제 없을 때,.. .임시DB내의 데이터를 SideDB에 초종 반영합니다.</li>\n</ul>\n</li>\n</ul>\n<h1>버전1.3 추가 (GDRP 개인데이터 보호 기능강화)</h1>\n<ul>\n<li>\n<p>1.2에서 사이드DB를 통해 개인정보 노출을 통제하고, 관리,삭제가 가능해 짐.</p>\n</li>\n<li>\n<p>1.3에서는 영지식증명을 통한 트렌젝션 익명성강화</p>\n</li>\n<li>\n<p>블록체인의 데이터 유효한 거래 및 기간 설정을 통해,... 접근통제관리</p>\n</li>\n</ul>","frontmatter":{"date":"February 12, 2019","title":"하이퍼레저 패브릭 1.2 컨셉요약","description":"하이퍼레저 패브릭 1.2 컨셉요약","tags":["hyperledger fabric"]}}},"pageContext":{"id":"3334134a-8d79-51d0-850e-e6164cdd339f"}}